Here’s a concrete, implementable MVP spec that integrates:

* your **idea**
* the **look & feel**
* the **drone scripting architecture**
* and the change: **no turrets, only stationary melee “drone warriors” built from iron**.

I’ll structure it as a vertical-slice MVP you can actually build in Rust/Bevy.

---

## 0. High-level MVP Goal

**Deliverable:**
A small, top-down, tile-based Rust/Bevy game where:

1. You see a **single Z-level** of a 3D grid world.
2. You have **worker drones** that:

   * mine **stone** and **iron** when given tasks,
   * tasks are created by selecting tile areas + entering **natural language text**,
   * that text is converted (mock or real) to a **JSON AST program** which is executed.
3. You can **spend iron** to build **stationary melee drone warriors** on designated tiles.
4. Simple **enemy waves** approach your base; enemies path towards a core point.
5. **Drone warriors automatically attack enemies** in adjacent tiles; they cannot move.
6. If enemies reach your core and damage it enough, you lose.

That’s the vertical slice.

---

## 1. World & Rendering

### 1.1 Grid & Levels

* World: 3D grid `(x, y, z)` but MVP uses **1–2 levels** practically.
* Recommended MVP size: `64x64` tiles, `z = 0..2`.
* For v0, gameplay only on `z = 0` but code supports `z` dimension.

```rust
struct Tile {
    kind: TileKind,             // Air, Stone, Iron, Floor, Wall, Core, WarriorSpot, etc.
    hardness: u8,               // mining hits required (optional)
}

enum TileKind {
    Air,
    Stone,
    Iron,
    Floor,
    Wall,
    Core,                       // base tile to defend
    WarriorSpot,                // allowed position for drone warriors
}

struct World {
    tiles: Vec<Tile>,
    width: i32,
    height: i32,
    levels: i32,
}
```

### 1.2 Rendering

* **Top-down 2D** Bevy camera.
* Render only tiles where `tile.z == CurrentLayer.0`.
* Tiles as **colored rectangles** for MVP:

  * Stone: dark gray
  * Iron: orange/gray mix
  * Floor: light gray
  * Wall: brown
  * Core: bright cyan
  * WarriorSpot: outlined tile / special tint
* Drones, enemies, warriors as small squares/circles.

```rust
struct CurrentLayer(pub i32);
```

---

## 2. Entities & Components

### 2.1 Worker Drone

Represents an **automation unit** controlled by your DSL program.

```rust
struct WorkerDrone;

enum DroneStatus {
    Idle,
    Thinking,  // waiting for LLM / AST
    Working,   // executing program
    Finished,
}

struct DroneTaskRef(Option<TaskId>); // link to Task entity

struct Position {
    x: i32,
    y: i32,
    z: i32,
}

struct Path {
    tiles: Vec<(i32, i32, i32)>;
    current_index: usize;
}
```

### 2.2 Drone Warrior (Melee Turret)

Stationary combat drone, crafted from iron and placed on a `WarriorSpot` tile.

```rust
struct DroneWarrior;

struct WarriorStats {
    hp: i32,
    attack_damage: i32,
    attack_cooldown: f32,   // seconds
    attack_range: i32,      // tiles (MVP = 1, adjacent tiles)
    time_since_last_attack: f32,
}
```

**Behavior:**

* Cannot move.
* Every frame:

  * find enemy within `attack_range` (simple “first found”).
  * if in range and `time_since_last_attack >= attack_cooldown`:

    * deal `attack_damage` to enemy.
    * reset cooldown.

### 2.3 Enemy

Basic enemy that walks toward the core.

```rust
struct Enemy;

struct EnemyStats {
    hp: i32,
    damage: i32,
    move_cooldown: f32,
    time_since_last_move: f32,
}

struct TargetCore;
```

* Pathfinding: simple grid A* from spawn edge to core tile (z = 0).

### 2.4 Core / Base

* A single `TileKind::Core` with:

```rust
struct Core {
    hp: i32,
    max_hp: i32,
}
```

* Lose condition: `core.hp <= 0`.

---

## 3. Resources, Economy & Crafting

### 3.1 Global Resources

```rust
struct Resources {
    stone: i32,
    iron: i32,
}
```

Shown in **top HUD**.

### 3.2 Mining

* Stone & iron exist as tile types.

* When a drone mines a tile:

  * Convert tile to `Floor` or `Air`.
  * Add resources:

    * Stone tile → `stone += 1`
    * Iron tile → `iron += 1`

* Mining is triggered through **tasks** (mouse area + text → DSL).

### 3.3 Building Drone Warriors

* Player selects a `WarriorSpot` tile (via UI + mouse click).
* If `iron >= COST_PER_WARRIOR`:

  * Deduct iron
  * Spawn `DroneWarrior` entity at that tile.
  * Mark tile as “occupied”.

```rust
const IRON_COST_PER_WARRIOR: i32 = 10; // MVP default
```

Warrior creation can be MVP-simple:

* Use a **build mode**:

  * Press `W` = “place warrior”.
  * Left-click on `WarriorSpot` tile:

    * If enough iron and spot empty → build.

Later this can be integrated into DSL tasks.

---

## 4. Task System & Drone Scripting

### 4.1 Task UX

* Player workflow (MVP):

  1. Hit `M` (mine mode).
  2. Drag a rectangle on map.
  3. Text popup opens at bottom:

     * “Describe what to do with this area:”
     * Player types NL, e.g.:
       `mine all iron in this area`
  4. Game:

     * status on chosen worker drone: `Thinking…`
     * Simulate LLM → produce JSON AST.
     * Validate AST; if valid:

       * create `Task` entity.
       * assign to an idle drone.
       * Drone status → `Working`.
     * When AST program finishes → Drone status → `Finished`.

### 4.2 Task Data

```rust
struct TaskId(u32);

struct Task {
    id: TaskId,
    description: String,   // short summary, can be LLM-generated
    status: TaskStatus,
}

enum TaskStatus {
    Pending,
    Assigned,
    InProgress,
    Completed,
    Failed,
}

struct TaskArea(TileBox3);
```

Line in **right panel**:

* `#3: Mine area (10,5,0)-(15,7,0) – In progress, Drone #1`

### 4.3 JSON AST Integration (Minimal Set)

You already have a detailed spec; MVP just needs a tiny subset:

* Types:

  * `TileCoord3`
  * `TileBox3`
  * `Int`

* Nodes:

  * `Program { statements: [...] }`
  * `Let`
  * `TileBoxFromCoords`
  * `Call` with host functions:

    * `mine_box(box: TileBox3)`
    * (optional) `build_wall_on_border(box: TileBox3)`

**Example AST for a mining task:**

```json
{
  "version": 1,
  "node": "Program",
  "statements": [
    {
      "node": "Let",
      "name": "area",
      "ty": "TileBox3",
      "value": {
        "node": "TileBoxFromCoords",
        "min": { "node": "TileCoord3", "x": 10, "y": 5, "z": 0 },
        "max": { "node": "TileCoord3", "x": 20, "y": 7, "z": 0 }
      }
    },
    {
      "node": "ExprStmt",
      "expr": {
        "node": "Call",
        "func": "mine_box",
        "args": [
          { "node": "VarRef", "name": "area" }
        ]
      }
    }
  ]
}
```

### 4.4 Execution Engine

* Implement a small **AST interpreter** directly in Rust (no bytecode yet):

  1. Parse JSON → typed AST.
  2. Validate:

     * correct node structure
     * known host functions
     * simple type checks.
  3. Execute statements:

     * `Let` → store in a map of variables.
     * `Call("mine_box", [TileBox3])`:

       * For each tile in `TileBox3`:

         * if tile is `Stone` or `Iron` → perform mining action (update world + resources).

* Execution is **per task**; worker drones “own” a program instance.

---

## 5. Enemy Waves & Combat Loop

### 5.1 Wave Spawner

* Global wave resource:

```rust
struct WaveState {
    current_wave: u32,
    time_to_next_wave: f32,   // seconds
    is_wave_active: bool,
}
```

* Logic:

  * Decrease `time_to_next_wave` each frame.
  * When it reaches 0:

    * Spawn `N` enemies at world edge (e.g., left side).
    * Set `is_wave_active = true`.
  * When all enemies are dead:

    * `current_wave += 1`
    * `time_to_next_wave = base_interval - wave_scaling * current_wave`
    * `is_wave_active = false`.

Wave info shown in **top HUD**:
`Wave 1 in 00:32`

### 5.2 Enemy Movement & Core Damage

* Each enemy pathfinds toward `Core` at `(cx, cy, 0)`.
* Every `move_cooldown` seconds, enemy moves one tile along path.
* If enemy reaches core tile:

  * `core.hp -= enemy.damage`
  * remove enemy or let them keep attacking.
* If `core.hp <= 0`: **Game Over**.

### 5.3 Drone Warrior Combat

* System runs each frame:

  ```rust
  fn warrior_attack_system(
      mut warriors: Query<(&Position, &mut WarriorStats), With<DroneWarrior>>,
      mut enemies: Query<(&Position, Entity, &mut EnemyStats), With<Enemy>>,
      time: Res<Time>,
      mut commands: Commands,
  ) {
      for (wpos, mut wstats) in &mut warriors {
          wstats.time_since_last_attack += time.delta_seconds();

          if wstats.time_since_last_attack < wstats.attack_cooldown {
              continue;
          }

          // Find first enemy in range
          if let Some((enemy_entity, mut enemy_stats)) = enemies.iter_mut()
              .find(|(epos, _, _)| in_range(wpos, epos, wstats.attack_range))
          {
              enemy_stats.hp -= wstats.attack_damage;
              wstats.time_since_last_attack = 0.0;
              if enemy_stats.hp <= 0 {
                  commands.entity(enemy_entity).despawn();
              }
          }
      }
  }
  ```

* `in_range` uses Manhattan or Chebyshev distance; MVP = `max(dx, dy) <= range`.

---

## 6. UI Layout

### 6.1 Main Layout

* **Center**: tile map (current Z-level).
* **Top HUD**:

  * `Stone: 12  |  Iron: 8  |  Wave 1 in 00:45  |  Core HP: 100/100`
* **Right Panel (bevy_egui)**:

  * Drone list:

    * `Drone #1 – Mining (10,5,0)-(15,7,0) – Working`
  * Task list:

    * `Task #3 – Mine area (10,5,0)-(15,7,0) – 80%`
* **Bottom console**:

  * Input line (for text commands / NL).
  * Log lines:

    * `> drone 1: mine area (10,5,0)-(15,7,0)`
    * `OK: Created task #3 (mine_box)`
    * `INFO: Gained 5 iron.`

### 6.2 Controls

* Mouse:

  * Left click: select tile / entity.
  * Left drag: select area (when in area mode).
  * Right click: cancel.
  * Middle/WASD: pan camera.
  * Scroll: zoom.
* Keyboard:

  * `M` – start **mine task** (area select + text).
  * `W` – **place warrior** mode (click on WarriorSpot).
  * `<`/`>` or PageUp/PageDown – cycle Z-level.
  * `Space` – pause/unpause game.
  * `Enter` – focus console input.
  * `ESC` – cancel current mode / exit menu.

---

## 7. Technical Implementation Plan (Rust / Bevy)

### 7.1 Crate & Dependencies

* `bevy` (core game).
* `bevy_egui` (UI panels).
* `serde` / `serde_json` (AST).
* Optional: `pathfinding` crate or your own A*.

### 7.2 Main Modules

* `world` – tiles, world generation.
* `entities` – drones, warriors, enemies, core.
* `resources` – global resource counts.
* `tasks` – task entities & states.
* `scripting` – JSON AST types, validation, interpreter.
* `combat` – warrior attack system, enemy damage system.
* `waves` – enemy spawning.
* `ui` – HUD, right panel, console.
* `input` – keyboard/mouse modes, area selection.

---

## 8. MVP Milestones

### Milestone 1 – World & Worker Drone

* Render 64×64 grid, z=0.
* Stone & iron tiles randomly distributed.
* One worker drone with simple “mine area” **hardcoded**, no AST yet.
* HUD shows stone/iron.

### Milestone 2 – Tasks & AST

* Area selection with `M`.
* Text entry pops up (NL).
* For MVP, **skip real LLM**: map NL → fixed AST or parse a simple command.
* Implement JSON AST + interpreter.
* Drone statuses: Idle / Thinking / Working / Finished.

### Milestone 3 – Enemies & Core

* Core tile with HP.
* Wave spawner.
* Enemies path to core and damage it.
* Game over when core HP = 0.

### Milestone 4 – Drone Warriors (Melee Turrets)

* Pre-defined `WarriorSpot` tiles on map.
* Resource check: spend iron to create a **DroneWarrior** at a spot.
* Warriors automatically attack enemies in adjacent tiles.
* Balancing: tune `IRON_COST_PER_WARRIOR`, enemy count, HP, damage so that:

  * You must mine → build warriors → survive wave.

---

## 9. Explicitly Out of Scope for MVP

* No **ranged turrets** (as requested).
* No moving warriors yet – they stay stationary.
* No complex building types (factories, power, etc.).
* No complex multi-floor gameplay (just `z = 0` for waves; higher layers only for future).
* No modding, no WASM mods, no sophisticated save/load (optional simple save later).

---

If you’d like, next step I can:

* Turn this into a **checklist** with concrete Bevy systems and structs, or
* Draft the initial **Rust module layout** (`mod world; mod tasks; ...`) with skeleton code for you to paste into a new project.
